import java.util.concurrent.atomic.AtomicInteger
import org.apache.jackrabbit.oak.api.Type
import org.apache.jackrabbit.oak.api.PropertyState
import org.apache.jackrabbit.oak.api.Blob
import org.apache.jackrabbit.oak.console.ConsoleSession
import org.apache.jackrabbit.oak.spi.state.NodeState
import org.apache.jackrabbit.oak.spi.state.NodeStore
import org.codehaus.groovy.tools.shell.CommandSupport
import org.codehaus.groovy.tools.shell.Groovysh
import groovy.transform.CompileStatic

/**
 * The {@code BinaryPathsCommand} class is a Groovy command designed to be used
 * within the Apache Jackrabbit Oak console environment. This command reads a file containing
 * blob IDs, typically generated by a datastore consistency check, and traverses the Oak
 * repository to find and print paths associated with these blob IDs.
 * 
 * <p>The command performs the following functions:</p>
 * <ul>
 *   <li>Reads a specified input file to gather a set of blob IDs.</li>
 *   <li>Traverses the repository starting from the root node.</li>
 *   <li>Identifies nodes containing binary properties and matches them against the blob IDs.</li>
 *   <li>Prints the paths of nodes with matching blob IDs.</li>
 * </ul>
 * 
 * <p>The command is executed in the context of a Groovy shell session and interacts
 * with the Oak {@code NodeStore} to access the repository data.</p>
 * 
 * <p>Usage:</p>
 * <pre>
 *   binary-paths &lt;path-to-gccand-file&gt;
 * </pre>
 * 
 * <p>Example:</p>
 * <pre>
 *   binary-paths /path/to/blobIds.txt
 * </pre>
 * 
 * <p>Note: This command requires the Oak environment and is intended for use by
 * administrators or developers familiar with Apache Jackrabbit Oak and AEM.</p>
 */
@CompileStatic
class BinaryPathsCommand extends CommandSupport {
    static final String COMMAND_NAME = 'binary-paths'

    BinaryPathsCommand(Groovysh shell) {
        super(shell, COMMAND_NAME, "binaryPaths")
    }

    @Override
    Object execute(List<String> args) {
        if (args.isEmpty()) {
            throw new IllegalArgumentException("Usage: binary-paths <path-to-gccand-file>")
        }

        String inputFilePath = args[0]
        ConsoleSession session = getSession()
        NodeStore nodeStore = session.getStore()

        File inputFile = new File(inputFilePath)
        if (!inputFile.exists()) {
            throw new IllegalArgumentException("Input file '${inputFilePath}' does not exist.")
        }

        // Use a HashSet for efficient storage and lookup of blob IDs
        Set<String> matchingBlobIds = new HashSet<>()

        // Read the file line by line and add each line to the HashSet
        inputFile.eachLine { line ->
            matchingBlobIds.add(line.trim())
        }

        // Start the traversal with the populated matchingBlobIds
        traverseNodeStore(nodeStore, matchingBlobIds)

        return null
    }

    private ConsoleSession getSession() {
        return (ConsoleSession) variables.get("session")
    }

    private void traverseNodeStore(NodeStore nodeStore, Set<String> matchingBlobIds) {
        NodeState rootNodeState = nodeStore.getRoot()
        AtomicInteger nodeCount = new AtomicInteger(0)
        AtomicInteger binaryCount = new AtomicInteger(0)
        AtomicInteger matchingBinaryCount = new AtomicInteger(0)

        println "Starting traversal of the repository"

        traverse(rootNodeState, "/", nodeCount, binaryCount, matchingBinaryCount, "/", matchingBlobIds)

        println "Total nodes: ${nodeCount.get()}"
        println "Total binaries: ${binaryCount.get()}"
        println "Total matching binaries: ${matchingBinaryCount.get()}"
    }

    private void traverse(NodeState node, String path, AtomicInteger nodeCount, AtomicInteger binaryCount, AtomicInteger matchingBinaryCount, String traversalPath, Set<String> matchingBlobIds) {
        nodeCount.incrementAndGet()

        if (path.startsWith(traversalPath)) {
            node.getProperties().each { PropertyState prop ->
                if (prop.getType() == Type.BINARY || prop.getType() == Type.BINARIES) {
                    processBinaries(prop, path, binaryCount, matchingBinaryCount, matchingBlobIds)
                }
            }
        }

        node.getChildNodeEntries().each { child ->
            traverse(child.getNodeState(), "${path}${child.getName()}/", nodeCount, binaryCount, matchingBinaryCount, traversalPath, matchingBlobIds)
        }
    }

    private void processBinaries(PropertyState prop, String path, AtomicInteger binaryCount, AtomicInteger matchingBinaryCount, Set<String> matchingBlobIds) {
        def binaries = prop.getType() == Type.BINARY ? [prop.getValue(Type.BINARY)] : prop.getValue(Type.BINARIES)
        binaries.each { Blob binary ->
            def blobId = binary.getContentIdentity()
            binaryCount.incrementAndGet()
            if (blobId && (matchingBlobIds.isEmpty() || matchingBlobIds.contains(blobId.split("#")[0]) || matchingBlobIds.contains(blobId))) {
                println "Blob Path : ${path} ==> ${blobId}"
                matchingBinaryCount.incrementAndGet()
            }
        }
    }
}